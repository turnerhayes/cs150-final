/*
 * Copyright Â© Thinking Robots, Inc., Tufts University, and others 2024.
 */

package edu.tufts.hrilab.action.planner.pddl;

import edu.tufts.hrilab.action.ActionBinding;
import edu.tufts.hrilab.action.Condition;
import edu.tufts.hrilab.action.Effect;
import edu.tufts.hrilab.action.db.ActionDBEntry;
import edu.tufts.hrilab.fol.Factory;
import edu.tufts.hrilab.fol.Predicate;
import edu.tufts.hrilab.fol.Symbol;
import edu.tufts.hrilab.fol.Term;
import edu.tufts.hrilab.fol.Variable;
import edu.tufts.hrilab.fol.util.Utilities;
import edu.tufts.hrilab.pddl.Operators;
import edu.tufts.hrilab.pddl.Pddl;
import edu.tufts.hrilab.util.Util;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Utils {

  /**
   * Turn an 'and' predicate into a Set of predicates.
   *
   * @param p
   * @return
   */
  public static Set<Predicate> expand(Predicate p) {
    Set<Predicate> expanded = new HashSet<>();
    if ("and".equals(p.getName())) {
      for (Symbol s : p.getArgs()) {
        if (s instanceof Predicate) {
          Predicate pe = (Predicate) s;
          expanded.addAll(expand(pe));
        }
      }
    } else {
      expanded.add(p);
    }
    return expanded;
  }

  /**
   * Checks if the term has variables that start with "!".
   *
   * @param term
   * @return
   */
  public static boolean containsLocalVariable(Term term) {
    return term.getVars().stream().anyMatch(var -> var.getName().startsWith("!"));
  }

  /**
   * Is predicate a DIARC operator or a known predicate in the PDDL domain.
   * @param predicate
   * @return
   */
  public static boolean isValidPredicate(Predicate predicate, Pddl.PddlBuilder builder) {
    Predicate testPred = predicate;
    if (predicate.isNegated()) {
      testPred = (Predicate) predicate.toUnnegatedForm();
    }
    if (Operators.DIARC_TO_PDDL.containsKey(testPred.getName()) || builder.getDomain().containsPredicate(testPred)) {
      return true;
    }
    return false;
  }

  /**
   * Does action have at least one valid PDDL effect. See isValidEffect for details
   * on what makes an Effect valid.
   *
   * @param action
   * @return
   */
  public static boolean hasValidEffect(ActionDBEntry action, Pddl.PddlBuilder builder) {
    for (Effect effect : action.getPostConditions()) {
      if (isValidEffect(effect, action, builder)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Is the Effect valid in the context of the given action and pddl builder. An Effect is valid if
   * it is not auto-generated, does not contain local script variables, and is fully
   * typed (free-variables and non-numeric literals).
   *
   * TODO: currently, literals need to be explicitly typed (e.g., cup:physobj) to be considered valid.
   *       This should probably use constants and objects to check if untyped literals are valid
   *
   * @param effect
   * @param action
   * @return
   */
  public static boolean isValidEffect(Effect effect, ActionDBEntry action, Pddl.PddlBuilder builder) {
    return !effect.isAutoGenerated()
            && !Utils.containsLocalVariable(effect.getPredicate())
            && isFullyTyped(effect, action, builder);
  }

  /**
   * Is the Condition valid in the context of the given action and pddl builder. A Condition is valid if
   * it does not contain local script variables and is fully typed (free-variables and non-numeric literals).
   *
   * @param condition
   * @param action
   * @return
   */
  public static boolean isValidCondition(Condition condition, ActionDBEntry action, Pddl.PddlBuilder builder) {
    return (!condition.getPredicates().keySet().stream()
            .anyMatch(predicate -> Utils.containsLocalVariable(predicate)))
            && isFullyTyped(condition, action, builder);
  }

  /**
   * Is the condition fully typed in the context of the given action and pddl problem/domain.
   * This checks that all variables and literals are typed by applying the semantic types of
   * the provided action roles (for free-variables) as well as the semantic types
   * of constants and objects (for literals). Numerical values do not need to be typed.
   *
   * @param condition
   * @param action
   * @return
   */
  public static boolean isFullyTyped(Condition condition, ActionDBEntry action, Pddl.PddlBuilder builder) {
    return condition.getPredicates().keySet().stream().allMatch(predicate -> {
      Predicate typedPredicate = (Predicate) applySemanticTypes(predicate, action, builder);
      return Utilities.isFullyTyped(typedPredicate);
    });
  }

  /**
   * Is the effect fully typed in the context of the given action and pddl problem/domain.
   * This checks that all variables and literals are typed by applying the semantic types of
   * the provided action roles (for free-variables) as well as the semantic types
   * of constants and objects (for literals). Numerical values do not need to be typed.
   *
   * @param effect
   * @param action
   * @return
   */
  public static boolean isFullyTyped(Effect effect, ActionDBEntry action, Pddl.PddlBuilder builder) {
    Predicate predicate = effect.getPredicate();
    Predicate typedPredicate = (Predicate) applySemanticTypes(predicate, action, builder);
    return Utilities.isFullyTyped(typedPredicate);
  }

  /**
   * Use the action (roles) and pddl builder (constants and objects) to apply semantic type information to the term.
   * @param term
   * @param action
   * @param builder
   * @return
   */
  public static Term applySemanticTypes(Term term, ActionDBEntry action, Pddl.PddlBuilder builder) {
    if (!edu.tufts.hrilab.fol.util.Utilities.isFullyTyped(term)) {
      List<Symbol> args = term.getArgs(); // shallow copy, will be modified in place
      for (int i = 0; i < args.size(); ++i) {
        Symbol arg = args.get(i);
        if (arg.isTerm()) {
          // recurse into nested predicates (e.g., not(fact(arg0,arg1)))
          args.set(i, applySemanticTypes((Term) arg, action, builder));
        } else if (arg.isVariable() && !arg.hasType()) {
          // try to find matching role for untyped variable
          ActionBinding matchingRole = action.getRoles().stream()
                  .filter(role -> role.getName().equals(arg.getName()) && role.hasSemanticType())
                  .findFirst().orElse(null);
          if (matchingRole != null) {
            Symbol typedArg = new Variable(arg.getName(), matchingRole.getSemanticType());
            args.set(i, typedArg);
          }
        } else if (!arg.hasType() && !Util.isNumeric(arg)) {
          // try to find semantic type for non-numeric literals
          Symbol typedArg = builder.getProblem().getObject(arg.getName());
          if (typedArg == null) {
            typedArg = builder.getDomain().getConstant(arg.getName());
          }
          if (typedArg != null) {
            args.set(i, typedArg);
          }
        }
      }

      // add newly typed predicat
      // NOTE: it's possible that the predicate is still not fully typed if the roles aren't all typed
      return Factory.createPredicate(term.getName(), args);
    } else {
      // already fully typed, just return it
      return term;
    }
  }

}
