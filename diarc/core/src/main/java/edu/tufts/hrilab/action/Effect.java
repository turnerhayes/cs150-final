/*
 * Copyright Â© Thinking Robots, Inc., Tufts University, and others 2024.
 */

/**
 * @author luca
 */

package edu.tufts.hrilab.action;

import edu.tufts.hrilab.action.db.ActionDBEntry;
import edu.tufts.hrilab.action.db.Database;
import edu.tufts.hrilab.action.execution.ActionContext;
import edu.tufts.hrilab.action.execution.ArgumentBasedContext;
import edu.tufts.hrilab.action.execution.Context;
import edu.tufts.hrilab.action.execution.ObservationContext;
import edu.tufts.hrilab.action.goal.Goal;
import edu.tufts.hrilab.fol.Predicate;
import edu.tufts.hrilab.action.justification.Justification;
import edu.tufts.hrilab.action.justification.ConditionJustification;
import edu.tufts.hrilab.fol.Symbol;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.Serializable;
import java.util.Objects;

/**
 * An Effect is the result of an action. It consists of a predicate (description of the effect),
 * an EffectType describing when that effect is presumed to hold, and if the effect should be observed
 * or assumed to hold (i.e., inferred).
 */
public class Effect implements Serializable {
  private static Logger log = LoggerFactory.getLogger(Effect.class);
  private static final long serialVersionUID = 3956261989056437765L;
  private EffectType type;
  private Observable observable;
  private boolean auto;
  private Predicate predicate;

  public Effect(Predicate p, EffectType t, Observable obs, boolean autoGenerated) {
    predicate = p;
    type = t;
    observable = obs;
    auto = autoGenerated;
  }

  public Effect(Predicate p, EffectType t, Observable obs) {
    this(p, t, obs, false);
  }

  public Effect(Predicate p, EffectType t) {
    this(p, t, Observable.DEFAULT, false);
  }

  /**
   * Using the roles from the ActionDBEntry, attempt to extract semantic type
   * information from the roles and apply them to the predicate(s) in this Effect.
   * @param actionDBEntry
   */
  public void applySemanticTypes(ActionDBEntry actionDBEntry) {
      predicate = new Predicate(actionDBEntry.applySemanticTypes(predicate));
  }

  /**
   * Bind the predicate in the effect to a context.
   *
   * @param context Context in which to look up variable bindings
   * @return New Effect with unbound arguments bound, if possible.
   */
  public Effect bindToContext(ArgumentBasedContext context) {
    Predicate boundPredicate = context.bindPredicate(predicate);
    return new Effect(boundPredicate, type, observable, auto);
  }

  public Predicate getPredicate() {
    return new Predicate(predicate);
  }

  /**
   * Get effect type. See below.
   * @return effect type
   */
  public EffectType getType() {
    return type;
  }

  /**
   * @return observable
   */
  public Observable getObservable() {
    return observable;
  }

  /**
   * @return true if effect is auto generated post condition (e.g. did-action)
   */
  public boolean isAutoGenerated() {
    return auto;
  }

  /**
   * Verify that effect is observed.
   * @param context context providing variable bindings
   * @return justification. true if effect applies, false if it can't be observed.
   */
  // FIXME: does not consider if effect is a side effect
  public Justification verify(ActionContext context) {
    if(observable == Observable.DEFAULT || observable == Observable.TRUE) {

      ObservationContext observationContext = context.getEffectObserver(this);
      if (observationContext != null) {   // Check that there is an observer available
        Symbol actor = (Symbol) context.getArgumentValue("?actor");
        if (!Database.getInstance().isDiarcAgent(actor)) {
          Context parentContext = context.getParentContext();
          while (parentContext != null) {
            parentContext = context.getParentContext();
            actor = (Symbol) parentContext.getArgumentValue("?actor");
            if (Database.getInstance().isDiarcAgent(actor)) {
              break;
            }
          }
        }
        Goal obs = new Goal(actor, predicate, observable);
        ActionInterpreter observer = ActionInterpreter.createInterpreterFromContext(obs, observationContext);
        log.debug("Starting observer goal: " + observer.getGoal());
        observer.call();

        // return results if was able to observe
        if (observationContext.isSuccess()) {
          return observationContext.getBoundObservationResults();
        }
      } else {
        if (observable == Observable.TRUE) {
          log.error("No observer for '" + this + "'");
        } else {
          log.trace("No observer for '" + this + "'");
        }
      }
    }

    if(observable == Observable.DEFAULT || observable == Observable.FALSE) {
      return new ConditionJustification(true, getPredicate());
    } else {
      return new ConditionJustification(false, getPredicate());
    }
  }

  @Override
  public String toString() {
    if (predicate != null) {
      return predicate.toString();
    } else {
      return "";
    }
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + Objects.hashCode(type);
    result = prime * result + Objects.hashCode(observable);
    result = prime * result + Objects.hashCode(auto);
    result = prime * result + Objects.hashCode(predicate);
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (!(o instanceof Effect)) {
      return false;
    }
    Effect other = (Effect) o;

    if (this.type != other.type) {
      return false;
    }
    if (this.observable != other.observable) {
      return false;
    }
    if (this.auto != other.auto) {
      return false;
    }
    if (!this.predicate.equals(other.predicate)) {
      return false;
    }
    return true;
  }
}
