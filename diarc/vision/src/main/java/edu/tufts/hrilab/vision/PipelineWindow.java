
/*
 * Copyright Â© Thinking Robots, Inc., Tufts University, and others 2024.
 */

package edu.tufts.hrilab.vision;

import edu.tufts.hrilab.vision.stm.CompositeSearchManager;
import edu.tufts.hrilab.vision.stm.RelationSearchManager;
import edu.tufts.hrilab.vision.stm.SearchManager;
import edu.tufts.hrilab.vision.stm.SimpleSearchManager;
import edu.tufts.hrilab.vision.visionproc.VisionProcess;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * PipelineWindow Class.
 * This class holds all the methods to
 * run the vision pipeline GUI. It handles adding ,removing, and highlighting
 * search managers and giving the relevant information to the visualization
 * class so that it can display the information properly .
 * @author nbarris
 */
public class PipelineWindow extends javax.swing.JFrame {

    // Every VisionProcess in the Pipeline, including duplicates
    private List<VisionProcess> fullPipelineList = new ArrayList();
    // Every VisionProcess in the Pipeline, not including duplicates
    private Set <VisionProcess> fullPipeline = new HashSet();
    // Every Search Manager that is displayed on the screen
    private List <Long> displayedSearchManagers = new ArrayList<>();
    // Which Search Manager is currently highlighted
    private Long highlightedSearchManager;
    // Composite Managers require a bit of special treatment due to duplicate manager IDs
    private Set <Long> compositeSearchComponents = new HashSet();
    // The list of running available managers. Updated from CameraControlPanel
    DefaultListModel <SearchManager> availManagers = new DefaultListModel<>();
    // The Visualization panel
    private PipelineVisualization visualization = new PipelineVisualization(fullPipeline, availManagers);
    private static Logger log = LoggerFactory.getLogger(PipelineWindow.class);

    /**
     * Creates new form PipelineWindow
     */
    public PipelineWindow() {
        initComponents();
        initVisualization();
    }

    /**
     * Initializes the buttons and the list model
     */
    private void initVisualization() {
        highlightedSearchManager = null;
        pipelinePanel.add(visualization, BorderLayout.CENTER);
        addSearchManagerButton.setEnabled(true);
        highlightButton.setEnabled(false);
        stopSearchManagerButton.setEnabled(false);
        clearSearchManagerButton.setEnabled(false);
        availSearchManagers_list.setModel(availManagers);
        availSearchManagers_list.setSelectedIndex(0);
    }

    /**
     * Will do a clean reset on items in the pipeline and add back all items that were
     * previously displayed. Useful for sudden removal of search managers or updates
     * to existing search managers.
     */
    public void resetVisualization() {
        fullPipeline.clear();
        for (int i = 0; i < availManagers.getSize(); i++) {
            SearchManager current = availManagers.get(i);
            // If it was once displayed and is simple or relational, it will be added again
            if (displayedSearchManagers.contains(current.getTypeId()) && !compositeSearchComponents.contains(current.getTypeId()))
                fullPipeline.addAll(current.getAllVisionProcessors());
            // If it was once displayed and is the main composite search, it will be added again
            else if (displayedSearchManagers.contains(current.getTypeId()) && compositeSearchComponents.contains(current.getTypeId())
                    && current instanceof CompositeSearchManager) {
                fullPipeline.addAll(current.getAllVisionProcessors());
            }
        }
        refreshGUI();
    }

    /**
     * Retrieves a list of running search managers and populates the
     * list of availManagers
     * @param running
     */
    public void updateList(DefaultListModel <SearchManager> running) {
        availManagers.removeAllElements();
        for (int i = 0; i < running.getSize(); i++) {
            SearchManager current = running.getElementAt(i);
            if (current instanceof CompositeSearchManager)
                compositeSearchComponents.add(current.getTypeId());
            availManagers.addElement(current);
        }
        refreshGUI();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        jScrollPane17 = new javax.swing.JScrollPane();
        availSearchManagers_list = new javax.swing.JList();
        addSearchManagerButton = new javax.swing.JButton();
        stopSearchManagerButton = new javax.swing.JButton();
        clearSearchManagerButton = new javax.swing.JButton();
        highlightButton = new javax.swing.JButton();
        pipelinePanel = new javax.swing.JPanel();

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel6.setText("Search Managers");

        availSearchManagers_list.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        availSearchManagers_list.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                availSearchManagers_listMouseClicked(evt);
            }
        });
        availSearchManagers_list.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                availSearchManagers_listValueChanged(evt);
            }
        });
        jScrollPane17.setViewportView(availSearchManagers_list);

        addSearchManagerButton.setText("Add");
        addSearchManagerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addSearchManagerButtonActionPerformed(evt);
            }
        });

        stopSearchManagerButton.setText("Remove");
        stopSearchManagerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopSearchManagerButtonActionPerformed(evt);
            }
        });

        clearSearchManagerButton.setText("Clear");
        clearSearchManagerButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearSearchManagerButtonActionPerformed(evt);
            }
        });

        highlightButton.setText("Highlight");
        highlightButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                highlightButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel6, javax.swing.GroupLayout.DEFAULT_SIZE, 207, Short.MAX_VALUE)
                    .addComponent(jScrollPane17, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(addSearchManagerButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(stopSearchManagerButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(clearSearchManagerButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(highlightButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane17)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(addSearchManagerButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(stopSearchManagerButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(clearSearchManagerButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(highlightButton)
                .addGap(23, 23, 23))
        );

        jSplitPane1.setLeftComponent(jPanel1);

        pipelinePanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        pipelinePanel.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                pipelinePanelMouseDragged(evt);
            }
        });
        pipelinePanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                pipelinePanelMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                pipelinePanelMouseReleased(evt);
            }
        });
        pipelinePanel.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                pipelinePanelComponentResized(evt);
            }
        });
        pipelinePanel.setLayout(new java.awt.BorderLayout());
        jSplitPane1.setRightComponent(pipelinePanel);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1146, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 594, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Handles the process of dragging a node on the screen
     * @param evt
     */
    private void pipelinePanelMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pipelinePanelMouseDragged
        visualization.mouseDrag(evt);
    }//GEN-LAST:event_pipelinePanelMouseDragged

    /**
     * Handles pressing a node, passes event information to visualization class
     * @param evt
     */
    private void pipelinePanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pipelinePanelMousePressed
        visualization.mousePress(evt);
    }//GEN-LAST:event_pipelinePanelMousePressed

    /**
     * On the release of a node, the location of that node is saved for future re-paints
     * @param evt
     */
    private void pipelinePanelMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_pipelinePanelMouseReleased
        visualization.mouseRelease(evt);
        refreshGUI();
    }//GEN-LAST:event_pipelinePanelMouseReleased

    /**
     * Handles the resizing of the window
     * @param evt
     */
    private void pipelinePanelComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_pipelinePanelComponentResized
        visualization.computeLayout();
        visualization.windowCheck();
        visualization.repaint();
    }//GEN-LAST:event_pipelinePanelComponentResized

    /**
     * Highlights a path
     * @param evt
     */
    private void highlightButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_highlightButtonActionPerformed
        SearchManager selectedSearchType = (SearchManager) availSearchManagers_list.getSelectedValue();
        if (selectedSearchType != null) {
            if (visualization.isHighlighted(selectedSearchType)) {
                visualization.clearHighlight();
                highlightedSearchManager = null;
                refreshGUI();
            }
            else {
                visualization.clearHighlight();
                visualization.toHighlight(selectedSearchType);
                highlightedSearchManager = selectedSearchType.getTypeId();
                refreshGUI();
            }
        }
    }//GEN-LAST:event_highlightButtonActionPerformed

    /**
     * Will return true if the current search manager has been displayed
     * Potentially will fail if a detector is shared between two search managers
     */
    public boolean isDisplayed(SearchManager current) {
        /*if (current instanceof SimpleSearchManager || current instanceof RelationSearchManager) {
            return displayedSearchManagers.contains(current.getTypeId());
        }
        else {*/
        Set <VisionProcess> toCheck = current.getAllVisionProcessors();
        if (fullPipeline.containsAll(toCheck)) {
            if (displayedSearchManagers.contains(current.getTypeId()))
                return true;
        }
        return false;
    }

    /**
     * Will return the list model that contains the available managers
     * @return
     */
    public DefaultListModel <SearchManager> getSearchManagerList() {
        return availManagers;
    }

    /**
     * Checks to see if the visionprocesses for a specific searchmanager are currently displayed
     * @param current
     * @return
     */
    public boolean IdDisplayed(SearchManager current) {
        return displayedSearchManagers.contains(current.getTypeId());
    }

    /**
     * If the contents of the list are updated while the pipeline is displayed, it will update the pipeline
     * to account for those differences
     * @param current
     */
    public void contentUpdate(SearchManager current) {
        // If a constraint is added to a composite search manager component, the actual composite
        // search is the one that will be refreshed rather than the individual component
        if (compositeSearchComponents.contains(current.getTypeId())) {
            for (int i = 0; i < availManagers.getSize(); i++) {
                if (availManagers.get(i).getTypeId() == current.getTypeId() && availManagers.get(i) instanceof
                        CompositeSearchManager)
                    current = availManagers.get(i);
            }
        }
        // Will locate the manager that needs to be updated and refresh it so that the GUI can be dynamic
        for (int i = 0; i < availManagers.getSize(); i++) {
            if (current.getTypeId() == availManagers.get(i).getTypeId() && IdDisplayed(availManagers.get(i))) {
                if (highlightedSearchManager != null) {
                    if (highlightedSearchManager == current.getTypeId()) {
                        visualization.clearHighlight();
                        remSearchManager(current);
                        addSearchManager(current);
                        visualization.toHighlight(current);
                    }
                    else {
                        remSearchManager(current);
                        addSearchManager(current);
                    }
                }
                else {
                    remSearchManager(current);
                    addSearchManager(current);
                }
            }
        }
    }

    /**
     * Enables or disables buttons based on whether processes are currently running or not
     */
    public synchronized void updateSearchManagerPanel() {
        if (availSearchManagers_list.getModel().getSize() > 0 && !availSearchManagers_list.isSelectionEmpty()) {
            SearchManager selectedSearchType = (SearchManager) availSearchManagers_list.getSelectedValue();
            visualization.updateCurrentSearch(selectedSearchType);
            if (isDisplayed(selectedSearchType)) {
                addSearchManagerButton.setEnabled(false);
                highlightButton.setEnabled(true);
                stopSearchManagerButton.setEnabled(true);
                clearSearchManagerButton.setEnabled(true);
            }
            else {
                addSearchManagerButton.setEnabled(true);
                highlightButton.setEnabled(false);
                stopSearchManagerButton.setEnabled(false);
            }
            // Handles special case of composite search manager having multiple parts
            if ((compositeSearchComponents.contains(selectedSearchType.getTypeId()) &&
                    !(selectedSearchType instanceof CompositeSearchManager))) {
                addSearchManagerButton.setEnabled(false);
                stopSearchManagerButton.setEnabled(false);
            }
        }
    }

    /**
     * Removes a search manager from the visualization
     * @param SearchType
     * */
    public void remSearchManager(SearchManager SearchType) {
        Set <VisionProcess> toRemove = SearchType.getAllVisionProcessors();
        // Removes vision processors from full list
        Iterator<VisionProcess> it = toRemove.iterator();
        while (it.hasNext()) {
            VisionProcess current = it.next();
            Iterator <VisionProcess> full_it = fullPipelineList.iterator();
            while (full_it.hasNext()) {
                VisionProcess full_check = full_it.next();
                if (full_check == current) {
                    full_it.remove();
                    break;
                }
            }
        }
        // Clears and then repopulates set
        fullPipeline.clear();
        fullPipeline.addAll(fullPipelineList);
        displayedSearchManagers.removeAll(SearchType.getRelatedTypeIds());

        // Reboots visualization
        if (visualization.isHighlighted(SearchType))
            visualization.clearHighlight();

        // Removes selected manager from list of dragged nodes
        visualization.clearDragNodes(SearchType);
        resetVisualization();
    }

    /**
     * Removes a search from the visualization panel.
     * @param evt
     */
    private void stopSearchManagerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopSearchManagerButtonActionPerformed
        SearchManager selectedSearchType = (SearchManager) availSearchManagers_list.getSelectedValue();
        remSearchManager(selectedSearchType);

        updateSearchManagerPanel();
    }//GEN-LAST:event_stopSearchManagerButtonActionPerformed

    /**
     * Will add a search Manager to the visualization
     * @param SearchType
     */
    public void addSearchManager(SearchManager SearchType)
    {
        displayedSearchManagers.addAll(SearchType.getRelatedTypeIds());
        fullPipelineList.addAll(SearchType.getAllVisionProcessors());
        fullPipeline.addAll(SearchType.getAllVisionProcessors());
        refreshGUI();
    }

    /**
     * When a search manager is added, it cues the visualization for that search manager and updates buttons
     * accordingly.
     * @param evt
     */
    private void addSearchManagerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addSearchManagerButtonActionPerformed
        SearchManager selectedSearchType = (SearchManager) availSearchManagers_list.getSelectedValue();
        addSearchManager(selectedSearchType);

        // Updating buttons
        updateSearchManagerPanel();
    }//GEN-LAST:event_addSearchManagerButtonActionPerformed

    /**
     * Clears the pipeline 
     * @param evt
     */
    private void clearSearchManagerButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearSearchManagerButtonActionPerformed
        fullPipelineList.clear();
        fullPipeline.clear();
        displayedSearchManagers.clear();
        visualization.clearHighlight();
        refreshGUI();

        // Button management
        updateSearchManagerPanel();

        visualization.clearDragNodes();
        resetVisualization();
    }//GEN-LAST:event_clearSearchManagerButtonActionPerformed

    /**
     * If the user clicks on a different entry in the list, the buttons adjust
     * @param evt
     */
    private void availSearchManagers_listValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_availSearchManagers_listValueChanged
        if (evt.getValueIsAdjusting() == false)
            updateSearchManagerPanel();
        refreshGUI();
    }//GEN-LAST:event_availSearchManagers_listValueChanged

    /**
     * If an entry in the list is double-clicked, it will be highlighted
     * @param evt
     */
    private void availSearchManagers_listMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_availSearchManagers_listMouseClicked
        SearchManager selectedSearchType = (SearchManager) availSearchManagers_list.getSelectedValue();
        switch(evt.getButton()){
            case 1: // Left click
                // If a manager has been double clicked, it will highlight the path
                if (evt.getClickCount() == 2) {
                    if (isDisplayed(selectedSearchType))
                        highlightButtonActionPerformed(null);
                    else if (addSearchManagerButton.isEnabled())
                        addSearchManagerButtonActionPerformed(null);
                }
        }
    }//GEN-LAST:event_availSearchManagers_listMouseClicked

    /**
     * Refreshes the visualization pipeline
     */
    public void refreshGUI() {
        visualization.createNodes(displayedSearchManagers);
        visualization.computeLayout();
        visualization.windowCheck();
        visualization.repaint();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(PipelineWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(PipelineWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(PipelineWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(PipelineWindow.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new PipelineWindow().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addSearchManagerButton;
    private javax.swing.JList availSearchManagers_list;
    private javax.swing.JButton clearSearchManagerButton;
    private javax.swing.JButton highlightButton;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane17;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JPanel pipelinePanel;
    private javax.swing.JButton stopSearchManagerButton;
    // End of variables declaration//GEN-END:variables
}
